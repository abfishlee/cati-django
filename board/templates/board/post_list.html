<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>파이썬 모델 기반 게시판</title>
    <!-- 외부 라이브러리 로드 (CSS & JS) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/ag-grid-community/dist/ag-grid-community.min.js"></script>
    <!-- 커스텀 스타일 정의 -->
    <style>
        body { font-family: 'Inter', sans-serif; /* 웹페이지 기본 폰트 설정 */ }
        .ag-theme-alpine { 
            --ag-header-background-color: #f8fafc; /* AG Grid 헤더 배경색 */
            --ag-row-hover-color: #f1f5f9; /* AG Grid 행에 마우스를 올렸을 때 배경색 */
        }
        .modal { 
            transition: opacity 0.25s ease; /* 모달창이 나타나고 사라질 때 부드러운 애니메이션 효과 */
        }
        body.modal-active { 
            overflow-y: hidden; /* 모달이 열렸을 때 배경 스크롤을 막음 */
        }
    </style>
</head>
<body class="bg-gray-50 text-gray-800">

    <!-- 메인 컨텐츠 영역 -->
    <div class="container mx-auto p-4 sm:p-6 lg:p-8">
        <!-- 페이지 헤더 -->
        <header class="mb-8 text-center">
            <h1 class="text-4xl font-bold text-gray-900">Django 모델 게시판</h1>
            <p class="mt-2 text-lg text-gray-600">AG Grid와 Tailwind CSS 활용</p>
        </header>

        <!-- 게시판 그리드가 위치할 카드 UI -->
        <div class="bg-white rounded-xl shadow-md overflow-hidden">
            <div class="p-6">
                <div class="flex justify-end mb-4">
                    <button id="addPostBtn" class="bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700 transition">새 글 작성</button>
                </div>
                <!-- AG Grid 라이브러리가 이 div를 실제 표(Grid)로 변환합니다. -->
                <div id="myGrid" class="ag-theme-alpine" style="height: 600px; width: 100%;"></div>
            </div>
        </div>
    </div>
    
    <!-- 게시글 작성/수정/조회 모달 (팝업창) -->
    <!-- 초기 상태: opacity-0(투명), pointer-events-none(클릭불가), z-50(매우 높은 z-index로 다른 요소 위에 표시) -->
    <div id="postModal" class="modal pointer-events-none fixed w-full h-full top-0 left-0 flex items-center justify-center opacity-0 z-50">
        <!-- 모달 뒷배경 (반투명 검은색) -->
        <div class="modal-overlay absolute w-full h-full bg-gray-900 opacity-50"></div>
        <!-- 모달 본문 컨테이너 (z-[51]로 뒷배경보다 한 단계 위에 표시) -->
        <div class="modal-container bg-white w-11/12 md:max-w-md mx-auto rounded-xl shadow-lg z-[51] overflow-y-auto">
            <div class="modal-content py-4 text-left px-6">
                <!-- 모달 헤더 (제목, 닫기 버튼) -->
                <div class="flex justify-between items-center pb-3 border-b">
                    <p id="modalTitle" class="text-2xl font-bold"></p>
                    <div id="modalClose" class="cursor-pointer z-50 p-2">
                        <svg class="fill-current text-black" xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0.0 0 18 18"><path d="M14.53 4.53l-1.06-1.06L9 7.94 4.53 3.47 3.47 4.53 7.94 9l-4.47 4.47 1.06 1.06L9 10.06l4.47 4.47 1.06-1.06L10.06 9z"></path></svg>
                    </div>
                </div>
                <!-- 게시글 입력 폼 -->
                <form id="postForm" class="mt-4">
                    <!-- Django의 CSRF(Cross-Site Request Forgery) 공격 방지 토큰. form 제출 시 반드시 필요합니다. -->
                    {% csrf_token %}
                    <!-- 수정/삭제 시 사용할 게시글의 ID를 저장하는 숨겨진 필드 -->
                    <input type="hidden" id="postId">
                    <!-- 입력 필드: 제목, 작성자, 내용 -->
                    <div class="mb-4"><label for="title" class="block text-sm font-bold mb-2">제목</label><input type="text" id="title" class="w-full px-3 py-2 border rounded-lg" required></div>
                    <div class="mb-4"><label for="author" class="block text-sm font-bold mb-2">작성자</label><input type="text" id="author" class="w-full px-3 py-2 border rounded-lg" required></div>
                    <div class="mb-4"><label for="content" class="block text-sm font-bold mb-2">내용</label><textarea id="content" rows="5" class="w-full px-3 py-2 border rounded-lg" required></textarea></div>
                    <!-- 버튼 영역: 삭제, 저장/수정 -->
                    <div id="modal-actions" class="flex items-center justify-end pt-4 border-t">
                        <button id="deleteBtn" type="button" class="bg-red-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-700 mr-2">삭제</button>
                        <button id="saveBtn" type="submit" class="bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700">저장</button>
                    </div>
                </form>
            </div>
        </div>
    </div>

 <script>
    // 'DOMContentLoaded' 이벤트는 HTML 문서가 완전히 로드되고 파싱되었을 때 발생합니다.
    // 스크립트가 <head>에 있더라도 body의 요소들을 안전하게 조작할 수 있게 해줍니다.
    document.addEventListener('DOMContentLoaded', () => {
        
        // --- 1. 초기화 및 변수 선언 ---
        // 스크립트 전체에서 사용할 HTML 요소들을 미리 찾아 변수에 할당합니다.
        // 이렇게 하면 코드가 더 깔끔해지고, 같은 요소를 여러 번 찾는 비효율을 막을 수 있습니다.
        const gridDiv = document.querySelector('#myGrid');
        const csrftoken = document.querySelector('[name=csrfmiddlewaretoken]').value;
        const modal = document.getElementById('postModal'), modalClose = document.getElementById('modalClose'), addPostBtn = document.getElementById('addPostBtn');
        const postForm = document.getElementById('postForm'), modalTitle = document.getElementById('modalTitle'), postIdInput = document.getElementById('postId');
        const titleInput = document.getElementById('title'), authorInput = document.getElementById('author'), contentInput = document.getElementById('content');
        const saveBtn = document.getElementById('saveBtn'), deleteBtn = document.getElementById('deleteBtn');
        let gridApi; // AG Grid의 API를 담을 변수. onGridReady 이후에 할당됩니다.

        // --- 2. AG Grid 설정 정의 ---
        // AG Grid에 표시될 컬럼(열)의 속성을 정의합니다.
        const columnDefs = [
            { headerName: "ID", field: "id", width: 80, sortable: true },
            { headerName: "제목", field: "title", flex: 2, sortable: true, filter: true }, // flex: 2는 다른 컬럼보다 2배의 너비를 차지하라는 의미
            { headerName: "작성자", field: "author", flex: 1, sortable: true },
            { 
                headerName: "생성일", field: "created_at", flex: 1, sortable: true,
                // valueFormatter: 서버에서 받은 날짜/시간 데이터(ISO 문자열)를
                // 한국 사용자가 보기 편한 형태(YYYY. MM. DD. 오전/오후 H:MM:SS)로 변환합니다.
                valueFormatter: params => params.value ? new Date(params.value).toLocaleString('ko-KR') : ''
            },
            {
                headerName: "관리", field: "id", width: 120, sortable: false, filter: false,
                // cellRenderer: 특정 셀의 HTML 내용을 직접 정의합니다.
                // 여기서는 '수정', '보기' 버튼을 동적으로 생성하고, 각 버튼의 onclick 이벤트에
                // 해당 행의 게시글 id(params.value)를 전달하는 함수를 연결합니다.
                cellRenderer: params => `
                    <button onclick="handleEdit(${params.value})" class="bg-green-500 text-white text-sm py-1 px-2 rounded hover:bg-green-600">수정</button>
                    <button onclick="handleView(${params.value})" class="bg-gray-500 text-white text-sm py-1 px-2 rounded hover:bg-gray-600 ml-1">보기</button>
                `
            }
        ];

        // AG Grid의 전반적인 옵션을 정의합니다.
        const gridOptions = {
            columnDefs: columnDefs, // 위에서 정의한 컬럼 설정
            pagination: true,       // 페이지네이션(페이지 나누기) 기능 활성화
            paginationPageSize: 15, // 한 페이지에 15개 행을 표시
            // onGridReady: AG Grid가 모든 초기화를 마치고 화면에 표시될 준비가 되었을 때 호출되는 함수입니다.
            // 이 시점에서 gridApi를 할당하고, 첫 데이터 로딩을 시작하는 것이 가장 안전합니다.
            onGridReady: (params) => {
                gridApi = params.api;
                fetchData(); // 그리드가 준비되면 데이터를 불러옵니다.
            }
        };

        // --- 3. 핵심 기능 함수 정의 ---
        
        /** 서버로부터 게시글 목록을 비동기적으로 가져와 그리드를 업데이트하는 함수 */
        const fetchData = async () => {
            if (!gridApi) return; // gridApi가 아직 준비되지 않았다면 함수를 종료합니다.
            gridApi.showLoadingOverlay(); // 데이터 요청 시작 시 'Loading...' 오버레이를 표시합니다.
            try {
                // await: fetch 요청이 완료되고 응답이 올 때까지 코드 실행을 기다립니다.
                const response = await fetch("{% url 'board:posts_api' %}");
                if (!response.ok) throw new Error(`서버 응답 실패: ${response.status}`);
                // await: 응답 본문을 JSON으로 파싱하는 과정이 끝날 때까지 기다립니다.
                const data = await response.json();
                gridApi.setRowData(data); // 성공적으로 받아온 데이터로 그리드의 내용을 교체합니다.
                gridApi.hideOverlay();    // 'Loading...' 오버레이를 숨깁니다.
            } catch (error) {
                console.error("데이터 로딩 중 에러 발생:", error);
                gridApi.showNoRowsOverlay(); // 에러 발생 시 'No Rows' 오버레이를 표시합니다.
                alert("데이터를 불러오는 데 실패했습니다. 개발자 콘솔을 확인해주세요.");
            }
        };
        
        /** 모달을 화면에 표시하는 함수 */
        const openModal = () => {
            modal.classList.remove('opacity-0', 'pointer-events-none');
            document.body.classList.add('modal-active');
        };

        /** 모달을 화면에서 숨기는 함수 */
        const closeModal = () => {
            modal.classList.add('opacity-0', 'pointer-events-none');
            document.body.classList.remove('modal-active');
        };

        // '수정', '보기' 버튼 클릭 시 호출될 함수들을 window 객체에 할당합니다.
        // cellRenderer에서 생성된 HTML 문자열 안의 onclick은 전역 스코프(window)에서 함수를 찾기 때문입니다.
        window.handleEdit = (id) => { fetch(`/board/api/posts/${id}/`).then(res => res.json()).then(post => setupModalForEdit(post)); };
        window.handleView = (id) => { fetch(`/board/api/posts/${id}/`).then(res => res.json()).then(post => setupModalForView(post)); };
        
        /** '새 글 작성' 모드를 위해 모달을 설정하고 엽니다. */
        const setupModalForCreate = () => {
            postForm.reset(); // 폼의 모든 입력 필드를 초기화합니다.
            postIdInput.value = ''; // id 필드를 비웁니다 (생성 모드임을 나타냄).
            modalTitle.textContent = '새 글 작성';
            saveBtn.textContent = '저장';
            deleteBtn.classList.add('hidden'); // 삭제 버튼 숨김
            saveBtn.classList.remove('hidden'); // 저장 버튼 표시
            // 모든 필드를 편집 가능 상태로 만듭니다.
            [titleInput, authorInput, contentInput].forEach(input => input.readOnly = false);
            openModal();
        };

        /** '글 수정' 모드를 위해 모달을 설정하고 엽니다. */
        const setupModalForEdit = (post) => {
            postIdInput.value = post.id;
            titleInput.value = post.title;
            authorInput.value = post.author;
            contentInput.value = post.content;
            modalTitle.textContent = '글 수정';
            saveBtn.textContent = '수정';
            deleteBtn.classList.remove('hidden'); // 삭제 버튼 표시
            saveBtn.classList.remove('hidden');   // 수정 버튼 표시
            [titleInput, authorInput, contentInput].forEach(input => input.readOnly = false);
            openModal();
        };

        /** '글 상세 보기' 모드를 위해 모달을 설정하고 엽니다. */
        const setupModalForView = (post) => {
            postIdInput.value = post.id;
            titleInput.value = post.title;
            authorInput.value = post.author;
            contentInput.value = post.content;
            modalTitle.textContent = '글 상세 보기';
            deleteBtn.classList.add('hidden'); // 삭제 버튼 숨김
            saveBtn.classList.add('hidden');   // 저장 버튼 숨김
            // 모든 필드를 읽기 전용 상태로 만듭니다.
            [titleInput, authorInput, contentInput].forEach(input => input.readOnly = true);
            openModal();
        };

        /** 폼 제출(저장/수정) 이벤트를 처리하는 함수 */
        const handleFormSubmit = (e) => {
            e.preventDefault(); // 폼의 기본 제출 동작(페이지 새로고침)을 막습니다.
            const id = postIdInput.value;
            const isCreating = !id;
            const url = isCreating ? "{% url 'board:create_post_api' %}" : `/board/api/posts/${id}/`;
            const method = isCreating ? 'POST' : 'PUT';
            
            fetch(url, {
                method: method,
                headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken },
                body: JSON.stringify({ title: titleInput.value, author: authorInput.value, content: contentInput.value })
            })
            .then(response => { if (!response.ok) throw new Error('Request failed'); return response.json(); })
            .then(() => { closeModal(); fetchData(); }) // 성공 시 모달을 닫고 그리드를 새로고침합니다.
            .catch(error => console.error('폼 제출 중 에러 발생:', error));
        };

        /** 삭제 버튼 클릭 이벤트를 처리하는 함수 */
        const handleDelete = () => {
            const id = postIdInput.value;
            if (id && confirm('정말로 이 글을 삭제하시겠습니까?')) {
                fetch(`/board/api/posts/${id}/`, {
                    method: 'DELETE',
                    headers: { 'X-CSRFToken': csrftoken }
                })
                .then(response => {
                    if (response.status === 204) { // 204 No Content는 성공적인 삭제를 의미합니다.
                        closeModal();
                        fetchData();
                    } else {
                        alert('삭제에 실패했습니다.');
                    }
                })
                .catch(error => console.error('삭제 중 에러 발생:', error));
            }
        };

        // --- 4. 이벤트 리스너(Event Listeners) 연결 ---
        // HTML 요소에 특정 이벤트(클릭, 제출 등)가 발생했을 때,
        // 위에서 정의한 함수들을 실행하도록 연결합니다.
        addPostBtn.addEventListener('click', setupModalForCreate);
        modalClose.addEventListener('click', closeModal);
        modal.querySelector('.modal-overlay').addEventListener('click', closeModal); // 모달 바깥 배경 클릭 시 닫기
        postForm.addEventListener('submit', handleFormSubmit);
        deleteBtn.addEventListener('click', handleDelete);
        
        // --- 5. 최종 실행 ---
        // 모든 변수, 설정, 함수, 이벤트 리스너가 준비된 후,
        // AG Grid를 실제 화면에 생성합니다.
        agGrid.createGrid(gridDiv, gridOptions);
    });
 </script>
</body>
</html>

